# https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_t
# A20 - LCS
# 文字列SとTの最長共通部分列 (LCS; Longest Common Subsequence) の長さを求める問題
"""
部分列: 文字列からいくつかの文字を選んでできる文字列 (選んだ文字の順番は変えられない)
その文字列から順番を変えずに一部の文字を取り出したものを指します。
たとえば grain は programming の部分列です
（4,5,6,9,10 文字目を取り出す）。
"""
S = input()
T = input()

# 動的計画法
N = len(S)
M = len(T)
dp = [ [0] * (M+1) for _ in range(N+1)]
"""
dp[i][j] は S[:i] と T[:j] の最長共通部分列の長さを保存。
行や列が 0 の領域は片方が空文字だから 0 固定。
二重ループで表を埋め切ると dp[N][M] が S 全体と T 全体の LCS 長になる。
"""

for i in range(1, N+1):
    for j in range(1, M+1):
        if S[i-1] == T[j-1]:
            # 文字が一致する場合, 
            # dp[i-1][j-1] + 1 : 今回一致した文字をLCSに採用し、ひとつ前の状態 dp[i-1][j-1] に 1 を足した長さ。
            # dp[i-1][j] : S の i 番目の文字を使わずに、S[:i-1] と T[:j] の LCS 長を引き継ぐ。
            # dp[i][j-1] : T の j 番目の文字を使わずに、S[:i] と T[:j-1] の LCS 長を引き継ぐ。
            dp[i][j] = max(dp[i-1][j-1]+1, dp[i-1][j], dp[i][j-1])
        else:
            # 文字が一致しない場合
            # dp[i-1][j] : S の i 番目の文字を使わずに、S[:i-1] と T[:j] の LCS 長を引き継ぐ。
            # dp[i][j-1] : T の j 番目の文字を使わずに、S[:i] と T[:j-1] の LCS 長を引き継ぐ。
            dp[i][j] = max(dp[i-1][j], dp[i][j-1])
# 出力
print(dp[N][M])


"""入力例
S = tokyo
T = kyoto
LCS は kyo (長さ3) になる

dpの中身
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 1, 1] # Sの1文字目tはTの4文字目と一致, i,j = 1, 4で1がつき、その後はマッチしなければ1が引き継がれる この時点でのLCSはt
[0, 0, 0, 1, 1, 2] # Sの2文字目oはTの3文字目と5文字目で一致, i,j = 2, 3または2, 5で、それぞれ1が足される LCSはto
[0, 1, 1, 1, 1, 2] # Sの3文字目kはTの1文字目と一致, i,j = 3, 1で1がつき、Tの4文字目まではLSCがkだが、Tの5文字目oでLCSがtoになるので2が引き継がれる
[0, 1, 2, 2, 2, 2] # Sの4文字目yはTの2文字目と一致, i,j = 4, 2で1がつき、Tの2文字目まではLSCはkyとなり、その後はkyとtoでどちらも長さが2なので2が引き継がれる
[0, 1, 2, 3, 3, 3] # Sの5文字目oはTの3文字目と5文字目で一致, i,j = 5, 3または5, 5で、それぞれ1が足される Tの3文字目でLCSはkyoとなり、Tの5文字目でもLCSはkyoのままなので3が引き継がれる
"""
